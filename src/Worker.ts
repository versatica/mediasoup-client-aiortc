import process from 'node:process';
import os from 'node:os';
import path from 'node:path';
import { spawn, execSync, ChildProcess } from 'node:child_process';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from 'mediasoup-client/lib/Logger';
import { EnhancedEventEmitter } from './enhancedEvents';
import { HandlerFactory } from 'mediasoup-client/lib/handlers/HandlerInterface';
import { Channel } from './Channel';
import * as media from './media';
import { AiortcMediaStream } from './AiortcMediaStream';
import { Handler } from './Handler';

// Whether the Python subprocess should log via PIPE to Node.js or directly to
// stdout and stderr.
const PYTHON_LOG_VIA_PIPE = process.env.PYTHON_LOG_TO_STDOUT !== 'true';
const IS_WINDOWS = os.platform() === 'win32';
const PYTHON = getPython();
const PIP_DEPS_DIR = path.join(__dirname, '..', 'worker', 'pip_deps');

const logger = new Logger('Worker');

export type WorkerSettings = {
	/**
	 * Logging level for logs generated by the Python subprocess.
	 */
	logLevel?: WorkerLogLevel;
};

export type WorkerLogLevel = 'debug' | 'warn' | 'error' | 'none';

export type WorkerEvents = {
	died: [Error];
	subprocessclose: [];
	// Private events.
	'@success': [];
	'@failure': [Error];
};

export class Worker extends EnhancedEventEmitter<WorkerEvents> {
	// Python worker child process.
	readonly #child: ChildProcess;
	// Worker process PID.
	readonly #pid: number;
	// Channel instance.
	readonly #channel: Channel;
	// Closed flag.
	#closed = false;
	// Died dlag.
	#died = false;
	// Worker subprocess closed flag.
	#subprocessClosed = false;
	// Handlers set.
	readonly #handlers: Set<Handler> = new Set();

	constructor({ logLevel }: WorkerSettings) {
		super();

		logger.debug('constructor() [logLevel:%o]', logLevel);

		const spawnBin = PYTHON;
		const spawnArgs: string[] = [];

		spawnArgs.push('-u'); // Unbuffered stdio.

		spawnArgs.push(path.join(__dirname, '..', 'worker', 'worker.py'));

		if (logLevel) {
			spawnArgs.push(`--logLevel=${logLevel}`);
		}

		logger.debug(
			'spawning worker process: %s %s',
			spawnBin,
			spawnArgs.join(' ')
		);

		this.#child = spawn(
			// command
			spawnBin,
			// args
			spawnArgs,
			// options
			{
				// Set PYTHONPATH env since we use custom locations for locally
				// installed PIP deps.
				env: {
					...process.env,
					PYTHONPATH: IS_WINDOWS
						? `${PIP_DEPS_DIR};${process.env.PYTHONPATH}`
						: `${PIP_DEPS_DIR}:${process.env.PYTHONPATH}`,
				},
				detached: false,
				// fd 0 (stdin)   : Just ignore it.
				// fd 1 (stdout)  : Pipe it for 3rd libraries that log their own stuff.
				// fd 2 (stderr)  : Same as stdout.
				// fd 3 (channel) : Channel fd.
				stdio: [
					'ignore',
					PYTHON_LOG_VIA_PIPE ? 'pipe' : 'inherit',
					PYTHON_LOG_VIA_PIPE ? 'pipe' : 'inherit',
					'pipe',
				],
			}
		);

		this.#pid = this.#child.pid!;

		this.#channel = new Channel({
			socket: this.#child.stdio[3],
			pid: this.#pid,
		});

		let spawnDone = false;

		// Listen for 'running' notification.
		this.#channel.once(String(this.#pid), (event: string) => {
			if (!spawnDone && event === 'running') {
				spawnDone = true;

				logger.debug('worker process running [pid:%s]', this.#pid);

				this.emit('@success');
			}
		});

		this.#child.on('exit', (code, signal) => {
			// If killed by ourselves, do nothing.
			if (this.#child.killed) {
				return;
			}

			if (!spawnDone) {
				spawnDone = true;

				if (code === 42) {
					logger.error(
						'worker process failed due to wrong settings [pid:%s]',
						this.#pid
					);

					this.close();
					this.emit('@failure', new TypeError('wrong settings'));
				} else {
					logger.error(
						'worker process failed unexpectedly [pid:%s, code:%s, signal:%s]',
						this.#pid,
						code,
						signal
					);

					this.close();
					this.emit(
						'@failure',
						new Error(`[pid:${this.#pid}, code:${code}, signal:${signal}]`)
					);
				}
			} else {
				logger.error(
					'worker process died unexpectedly [pid:%s, code:%s, signal:%s]',
					this.#pid,
					code,
					signal
				);

				this.#died = true;

				this.close();
				this.safeEmit(
					'died',
					new Error(`[pid:${this.#pid}, code:${code}, signal:${signal}]`)
				);
			}
		});

		this.#child.on('error', error => {
			// If killed by ourselves, do nothing.
			if (this.#child.killed) {
				return;
			}

			if (!spawnDone) {
				spawnDone = true;

				logger.error(
					'worker process failed [pid:%s]: %s',
					this.#pid,
					error.message
				);

				this.close();
				this.emit('@failure', error);
			} else {
				logger.error(
					'worker process error [pid:%s]: %s',
					this.#pid,
					error.message
				);

				this.close();
				this.safeEmit('died', error);
			}
		});

		this.#child.on('close', (code, signal) => {
			logger.debug(
				'worker subprocess closed [pid:%s, code:%s, signal:%s]',
				this.#pid,
				code,
				signal
			);

			this.#subprocessClosed = true;

			this.safeEmit('subprocessclose');
		});

		if (PYTHON_LOG_VIA_PIPE) {
			// Be ready for 3rd party worker libraries logging to stdout.
			this.#child.stdout!.on('data', buffer => {
				for (const line of buffer.toString('utf8').split('\n')) {
					if (line) {
						logger.debug(`(stdout) ${line}`);
					}
				}
			});

			// In case of a worker bug, mediasoup will log to stderr.
			this.#child.stderr!.on('data', buffer => {
				for (const line of buffer.toString('utf8').split('\n')) {
					if (line) {
						logger.error(`(stderr) ${line}`);
					}
				}
			});
		}
	}

	/**
	 * Worker process identifier (PID).
	 */
	get pid(): number {
		return this.#pid;
	}

	/**
	 * Whether the Worker is closed.
	 */
	get closed(): boolean {
		return this.#closed;
	}

	/**
	 * Whether the Worker subprocess died.
	 */
	get died(): boolean {
		return this.#died;
	}

	/**
	 * Whether the Worker subprocess is closed.
	 */
	get subprocessClosed(): boolean {
		return this.#subprocessClosed;
	}

	/**
	 * Close the Worker.
	 */
	close(): void {
		if (this.#closed) {
			return;
		}

		logger.debug('close()');

		this.#closed = true;

		// Kill the worker process.
		this.#child.kill('SIGTERM');

		// Close every Handler.
		for (const handler of this.#handlers) {
			handler.close();
		}
		this.#handlers.clear();

		// Close the Channel instance.
		this.#channel.close();
	}

	async dump(): Promise<any> {
		logger.debug('dump()');

		return this.#channel.request('dump');
	}

	/**
	 * Create a AiortcMediaStream with audio/video tracks.
	 */
	async getUserMedia(
		constraints: media.AiortcMediaStreamConstraints
	): Promise<AiortcMediaStream> {
		logger.debug('getUserMedia() [constraints:%o]', constraints);

		return media.getUserMedia(this.#channel, constraints);
	}

	/**
	 * Create a mediasoup-client HandlerFactory.
	 */
	createHandlerFactory(): HandlerFactory {
		logger.debug('createHandlerFactory()');

		return (): Handler => {
			const internal = { handlerId: uuidv4() };
			const handler = new Handler({
				internal,
				channel: this.#channel,
			});

			this.#handlers.add(handler);
			handler.on('@close', () => this.#handlers.delete(handler));

			return handler;
		};
	}
}

function getPython() {
	let python = process.env.PYTHON;

	if (!python) {
		try {
			execSync('python3 --version', { stdio: ['ignore', 'ignore', 'ignore'] });
			python = 'python3';
		} catch (error) {
			python = 'python';
		}
	}

	return python;
}
